"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = require("../../compile/codegen");
const types_1 = require("../discriminator/types");
const error = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag
        ? `tag "${tagName}" must be string`
        : `value of tag "${tagName}" must be in oneOf or anyOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,
};
const def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error,
    code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const keyword = parentSchema.hasOwnProperty("oneOf")
            ? "oneOf"
            : parentSchema.hasOwnProperty("anyOf")
                ? "anyOf"
                : undefined;
        if (!it.opts.discriminator) {
            throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
            throw new Error("discriminator: requires propertyName");
        if (!keyword)
            throw new Error("discriminator: requires the oneOf or anyOf composite keyword");
        const parentSchemaVariants = parentSchema[keyword];
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._) `typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
            const mapping = getMapping();
            gen.if(false);
            for (const tagValue in mapping) {
                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
                gen.assign(valid, applyTagSchema(mapping[tagValue]));
            }
            gen.else();
            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
            gen.endIf();
        }
        function applyTagSchema(schemaProp) {
            const _valid = gen.name("valid");
            const schCxt = cxt.subschema({ keyword, schemaProp }, _valid);
            cxt.mergeEvaluated(schCxt, codegen_1.Name);
            return _valid;
        }
        function isRef(schema) {
            return schema.hasOwnProperty("$ref");
        }
        function getMapping() {
            var _a;
            const discriminatorMapping = {};
            const topRequired = hasRequired(parentSchema);
            let tagRequired = true;
            for (let i = 0; i < parentSchemaVariants.length; i++) {
                const sch = parentSchemaVariants[i];
                let propSch;
                if (isRef(sch)) {
                    // compare the ref pointer to the one in mapping
                    if (schema.mapping) {
                        const { mapping } = schema;
                        let matchedKey;
                        Object.keys(mapping).forEach(function (key) {
                            if (mapping[key] === sch["$ref"]) {
                                matchedKey = key;
                            }
                        });
                        if (matchedKey) {
                            addMapping(matchedKey, i);
                        }
                        else {
                            throw new Error(`${sch["$ref"]} should have a corresponding entry in mapping`);
                        }
                    }
                    continue;
                }
                else {
                    // find if raw schema contains tagName
                    propSch = (_a = sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
                }
                if (typeof propSch != "object") {
                    throw new Error(`discriminator: ${keyword} schemas must have "properties/${tagName}"`);
                }
                tagRequired = tagRequired && (topRequired || hasRequired(sch));
                addMappings(propSch, i);
            }
            if (!tagRequired)
                throw new Error(`discriminator: "${tagName}" must be required`);
            return discriminatorMapping;
            function hasRequired({ required }) {
                return Array.isArray(required) && required.includes(tagName);
            }
            function addMappings(sch, i) {
                if (sch.const) {
                    addMapping(sch.const, i);
                }
                else if (sch.enum) {
                    for (const tagValue of sch.enum) {
                        addMapping(tagValue, i);
                    }
                }
                else {
                    throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
                }
            }
            function addMapping(tagValue, i) {
                if (typeof tagValue != "string" || tagValue in discriminatorMapping) {
                    throw new Error(`discriminator: "${tagName}" values must be unique strings`);
                }
                discriminatorMapping[tagValue] = i;
            }
        }
    },
};
exports.default = def;
//# sourceMappingURL=index.js.map